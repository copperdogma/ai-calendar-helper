#!/bin/bash

# Script to concatenate all .env files into combined_env.txt
# Similar to concatenate-codebase.sh for structure and headers.

# Output file
OUTPUT_FILE="combined_env.txt"
SCRIPT_NAME_BASENAME="$(basename "$0")"

# Clean previous output file
echo "[$SCRIPT_NAME_BASENAME] Cleaning previous $OUTPUT_FILE (if any)..."
rm -f "$OUTPUT_FILE"
# Create it fresh, ensuring it exists even if no .env files are found
touch "$OUTPUT_FILE"

# Add a header to the combined file
echo "# Combined .env files snapshot" > "$OUTPUT_FILE"
echo "# Generated by: $SCRIPT_NAME_BASENAME" >> "$OUTPUT_FILE"
echo "# Generated on: $(date)" >> "$OUTPUT_FILE"
echo "" >> "$OUTPUT_FILE"

# Find all .env and .env.* files in the current directory and subdirectories.
# Exclude paths like .git, node_modules, .next, dist, build to avoid irrelevant .env files.
echo "[$SCRIPT_NAME_BASENAME] Searching for .env and .env.* files..."
FOUND_ANY_FILES=false
find . -type d \( -name ".git" -o -name "node_modules" -o -name ".next" -o -name "dist" -o -name "build" \) -prune -o -type f \( -name ".env" -o -name ".env.*" \) -print0 | while IFS= read -r -d $'\0' file; do
  FOUND_ANY_FILES=true
  # Remove leading ./ from filename for cleaner header
  CLEAN_FILE_NAME="${file#./}"

  # Skip the output file itself if it somehow matches the pattern
  if [[ "$CLEAN_FILE_NAME" == "$OUTPUT_FILE" ]]; then
    echo "[$SCRIPT_NAME_BASENAME] Skipping output file $OUTPUT_FILE from concatenation."
    continue
  fi

  echo "[$SCRIPT_NAME_BASENAME] Adding $CLEAN_FILE_NAME to $OUTPUT_FILE..."

  # Get file size in bytes
  FILE_SIZE_BYTES=$(wc -c < "$file" | tr -d ' ')

  # Create header with file name and size padded to 80 chars with "=" symbols
  HEADER_TEXT="=== $CLEAN_FILE_NAME ($FILE_SIZE_BYTES bytes) "
  HEADER_LENGTH=${#HEADER_TEXT}
  PADDING_LENGTH=$((80 - HEADER_LENGTH))
  if (( PADDING_LENGTH < 0 )); then
    PADDING_LENGTH=0 # Ensure padding length is not negative
  fi
  PADDING=$(printf '%*s' "$PADDING_LENGTH" | tr ' ' '=')

  echo -e "\n\n$HEADER_TEXT$PADDING" >> "$OUTPUT_FILE"
  cat "$file" >> "$OUTPUT_FILE"
done

if [ "$FOUND_ANY_FILES" = false ]; then
  echo "[$SCRIPT_NAME_BASENAME] No .env files found to concatenate."
  echo "" >> "$OUTPUT_FILE" # Add a newline for consistent structure
  echo "# No .env files found in the project." >> "$OUTPUT_FILE"
fi

echo "" >> "$OUTPUT_FILE"
echo "--- End of combined .env files ---" >> "$OUTPUT_FILE"

echo "[$SCRIPT_NAME_BASENAME] Successfully concatenated .env files into $OUTPUT_FILE"

# Make the script executable by its owner and group, readable by others
# This makes it easier to run directly after checkout.
if [ -f "$0" ]; then
  chmod ug+x "$0"
  echo "[$SCRIPT_NAME_BASENAME] Made script $0 executable."
else
  echo "[$SCRIPT_NAME_BASENAME] Warning: Script file $0 not found, could not set executable permissions."
fi


echo "[$SCRIPT_NAME_BASENAME] Finished." 